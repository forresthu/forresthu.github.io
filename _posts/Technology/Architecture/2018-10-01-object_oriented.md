---

layout: post
title: 重新看面向对象设计
category: Architecture
tags: Architecture
keywords: 面向对象

---

## 简介

我一直有一个比方，如果把程序员写程序比作史官写历史，那么面向过程就是编年体通史，而面向对象更像是纪传体通史。编年体通史以时间（或一段时间）为中心，而纪传体通史则以人物为中心，譬如《史记》的《高祖本纪》等。类似的，面向过程多认为程序由一个个函数组成（依照顺序先后调用），譬如历史由一件件大事组成。而面向对象倾向于认为程序由一个个对象组成，譬如历史由一个个人的故事组成。

[Is Inheritance Dead? A Detailed Look Into the Decorator Pattern](https://dzone.com/articles/is-inheritance-dead)未读完

[编程就是压缩](https://mp.weixin.qq.com/s/bXl9IP5CyoNHND6dyXNFvA)
1. static compression 的目标：给定所有的当前需求，最小化整体的实现代码量。方法就是能复用就复用，不能简单的复用的，创造条件也要强行复用。
2. generalization ability 的目标：给定过去的需求，进行合理的预测，最小化迁移到未来可能的新需求的成本。其实现手段就是保持代码整洁，**有结构**。但是问题在于什么叫“有结构”很难学习。相反，最小化整体的实现代码量是一个更容易销售，也更容易学习的目标。这里“合理的预测”似乎和不要预先设计是矛盾的。然而所有的“泛化”都是某种预测。整洁有结构的代码“赌”的是什么呢？赌的就是新需求大概率是 localized 的。
3. 压缩的前提是对象本身具有内在的规律性。压缩的过程就是把规律性的部分和特异性的部分分离出来。这个也就体现在了各种“中台”，“低代码”，“DSL”的说辞之中，所谓一部分人搞定 80%，剩下的领域专家（也就是处理特异性的人）去搞定特异性的 20%。然而这里的前提是处理 20% 的人要先知道之前的工序做了哪部分的 80%，才能知道自己要做哪 20%。wetware 相比 hardware 就是自然进化的速度太慢，千兆网，万兆网，升级速度杠杠的。但是人与人的沟通还是要靠非常低效率的文字理解和声波通信。除非需求内在的 Regularity 非常强，可以用极其少量的参数组合已有功能来表达新需求，否则大概率写这 20% 代码的人会非常痛苦。这也是为什么“低代码”无法流行的根本原因。
4. 一部分人处理 Regularity，一部分人处理 Specificity：这就是所谓“中台”，“低代码”，“DSL”。核心是 specificity 部分要足够小，才能弥补沟通成本。人类来提供 Regularity，机器处理 Specificity：一开始是 logical programming，人类要提供非常多的 regularity。后来是 probabilistic programming，人类需要提供 generating function 来编码专家经验到概率分布里。到后来 deep neural network，人类需要用 convolution filter 来用所谓 inductive bias 的方式 encourage 神经网络往某个方向学习。越来越多的程序员会从直接编码规则来驾驭机器，变成“声明式编程”。把规律性的部分提取成 what，让机器去找到 how。

[一文教会你领域建模](https://mp.weixin.qq.com/s/3x4fK7rtA2US9fxoKpoAiA)
1. 为什么需要建模？ 想象一个应用程序，其代码有几十万行。如果使用C语言平均每个子程序编写50到100行代码，那么子程序就有几千到几万个。如果使用面向对象，平均在每个类中汇总10个子程序，那么类的总数就比子程序的总数减少1个数量级，为几百到几千个。当然，即便是1000个类，数量依然庞大。为了可理解性，我们可以按照内聚性，进一步使用“包”、“组件”、“模块”、“服务”做归类分组，以减少我们大脑的思维负担。**这就是我们为什么需要面向对象的原因**。可是，我们很多系统还是失控了。因为他们虽然使用了面向对象语言，但干的还是面向过程的勾当。体现在代码上，就是缺少对领域概念的清晰表达、缺乏面向对象的领域封装、领域边界模糊不清、以及领域模型抽象不正确。
    ![](/public/upload/kubernetes/domain_model.png)
2. 理解业务需求。如何理解？  用户故事，挖掘概念。我们可以借助更多的辅助手段，比如四色建模、事件风暴、专家会谈、阅读领域书籍等等。但归根结底，都是语言的思维游戏。领域建模作为一种能力，是可以通过《刻意练习》习得和不断提升的。越多的锻炼就能建立越强大的**心理表征**能力，届时，你会发现你已经不再需要这些“方法”的指引，更多的时候只是在用“直觉”。

## 抽象

[程序员必备的思维能力：抽象思维](https://mp.weixin.qq.com/s/cJ0odiYcphhNBoAVjqpCZQ)

抽象层次/**分层抽象**：抽象是以概念（词语）来反映现实的过程，每一个概念都有一定的外延和内涵．概念的外延就是适合这个概念的一切对象的范围，而概念的内涵就是这个概念所反映的对象的本质属性的总和．例如“平行四边形”这个概念，它的外延包含着一切正方形、菱形、矩形以及一般的平行四边形，而它的内涵包含着一切平行四边形所共有的“有四条边，两组对边互相平行”这两个本质属性。**一个概念的内涵愈广，则其外延愈狭；反之，内涵愈狭，则其外延愈广**，泛化能力越强。然而，其代价就是业务语义表达能力越弱。 例如，“平行四边形”的内涵是“有四条边，两组对边互相平行”，而“菱形”的内涵除了这两条本质属性外，还包含着“四边相等”这一本质属性。“菱形”的内涵比“平行四边形”的内涵广，而“菱形”的外延要比“平行四边形”的外延狭。所谓的抽象层次就体现在概念的外延和内涵上，这种层次性，基本可以体现在任何事物上。每一个抽象层次都有它的用途，对于我们工程师来说，如何拿捏这个抽象层次是对我们设计能力的考验，抽象层次太高和太低都不行。

我经常开玩笑说，你把所有的类都叫Object，把所有的参数都叫Map的系统最通用，因为Object和Map的内涵最小，其延展性最强，可以适配所有的扩展。从原理上来说，这种抽象也是对的，万物皆对象嘛。但是这种抽象又有什么意义呢？它没有表达出任何想表达的东西，只是一句正确的废话而已。越抽象，越通用，可扩展性越强，然而其语义的表达能力越弱。越具体，越不好延展，然而其语义表达能力很强。所以，**对于抽象层次的权衡，是我们系统设计的关键所在**，也是区分普通程序员和优秀程序员的关键所在。

[重拾面向对象软件设计](https://mp.weixin.qq.com/s/u-JEQmtFqSYFWRJ45RAFYw)面向对象的核心是抽象思维。**通过抽象提取共性，通过封装收敛逻辑，通过多态实现扩展**。面向对象的思想本质是将数据与行为做结合，数据与行为的载体称之为对象，而对象要负责的是定义职责的边界。但面向对象也不是银弹，甚至有些场景用比不用还糟，一切的根源就是抽象。我们在设计抽象进行分类时，不一定能抓住最合适的切入点，**错误的抽象比没有抽象复杂度更高**。在系统设计的早期，业务规则不复杂，逻辑复用与扩展体现得也并不强烈，而面向过程的代码在支撑这些相对简单的业务场景是非常容易的。但软件工程最大的成本在于维护，当系统足够复杂时，当初那些写起来最easy的代码，将来就是维护起来最hard的债务。

### 评价抽象

UML的创始人Grady booch在 Object Oriented Analysis and Design with Applications 一书中，提到了评判一种抽象的品质可以通过如下5个指标进行测量：耦合性、内聚性、充分性、完整性与基础性。
1. 耦合性，一个模块与其他模块高度相关，那它就难以独立得被理解、变化或修改。但这并不意味着我们就不需要耦合。软件设计是朝着扩展性与复用性发展的，继承天然就是强耦合，但它为我们提供了软件系统的复用能力。如同摩擦力一般，起初以为它阻碍了我们前进的步伐，实则没有摩擦力，我们寸步难行。
2. 内聚性，内聚性测量的是单个模块里，各个元素的的联系程度。内聚性分为偶然性内聚与功能性内聚。金鱼与消防栓，**我们一样可以因为它们都不会吹口哨，将他们抽象在一起，但很明显我们不该这么干，这就是偶然性内聚**。最希望出现的内聚是功能性内聚，即一个类或模式的各元素一同工作，提供某种清晰界定的行为。比如我将消防栓、灭火器、探测仪等内聚在一起，他们是都属于消防设施，这是功能性内聚。
3. 充分性，充分性指一个类或模块需要应该记录某个抽象足够多的特征，否则组件将变得不用。比如Set集合类，如果我们只有remove、get却没有add，那这个类一定没法用了，因为它没有形成一个闭环 。
4.  完整性，完整性指类或模块需要记录某个抽象全部有意义的特征。完整性与充分性相对，充分性是模块的最小内涵，完整性则是模块的最大外延。我们走完一个流程，可以清晰得知道我们缺哪些，可以让我们马上补齐抽象的充分性，但可能在另一个场景这些特征就又不够了，我们需要考虑模块还需要具备哪些特征或者他应该还补齐哪些能力。
5. 基础性，基础性指抽象底层表现形式最有效的基础性操作（似乎用自己在解释自己）。比如Set中的add操作，是一个基础性操作，在已经存在add的情况下，我们是否需要一次性添加2个元素的add2操作？很明显我们不需要，因为我们可以通过调用2次add来完成，所以add2并不符合基础性。但我们试想另一个场景，如果要判断一个元素是否在Set集合中，我们是否需要增加一个contains方法。Set已经有foreach、get等操作了，按照基础性理论，我们也可以把所有的元素遍历一遍，然后看该元素是否包含其中。但基础性有一个关键词叫“有效”，虽然我们可以通过一些基础操作进行组合，但它会消耗大量资源或者复杂度，那它也可以作为基础操作的一个候选者。

某个功能或数据，若没有归属于某个明显的职责范围，很可能就有相同的功能被多次实现，同一份数据被存放在多处。

### 软件设计原则

总体原则：**一切为了变更**，优秀的设计比糟糕的设计更容易变更。我刚刚做的事情让系统更容易改变，还是更难改变？

抽象的品质可以指导我们抽象与建模，但总归还是不够具象，在此基础上一些更落地更易执行的设计原则涌现出来，最著名的当属面向对象的五大设计原则 S.O.L.I.D。
1. 开闭原则OCP，对扩展开放，对修改关闭
2. 依赖倒置DIP，高层模块不应该依赖低层模块，两者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。
3. PLOA最小惊讶原则，如果必要的特征具有较高的惊人因素，则可能需要重新设计该特征。
4. KISS简单原则，保持愚蠢，保持简单

《敏捷软件开发》这本书把设计模式上升到设计思想的高度，书中说“软件设计不应该是面向需求设计，而应该是面向需求变更设计”，也就是说在设计的时候，主要要考虑的是当需求变更的时候，如何用最小的代价实现变更。优秀的工程师不应该害怕需求变更，而应该欢迎需求变革，因为优秀的工程师已经为需求变更做好了设计，如果没有需求变更，那就显示不出自己和只会重复的平庸工程师的区别。

## 封装

[Clean Code之封装：把野兽关进笼子](https://mp.weixin.qq.com/s/-dcXKWYeD-Y2SMq6MsVuSw)Dijkstra说：“软件是唯一的职业，人的思维要从一个字节大幅跨越到几百兆字节，也就是九个数量级（放在今天的话，恐怕还要再加上几个数量级）”。通过封装，我们可以实现信息隐藏（information hiding），把底层细节信息封装起来，隐藏起来，为上一层提供信息量更少的界面。通过这种方式，可以减少认知成本和大脑记忆负担，从而降低复杂度。不幸的是，软件不像收纳盒那样是一个物理的盒子，有物理边界。软件是软的，软件的收纳，只能通过“逻辑盒子”的封装来实现。复杂的系统都会呈现出层次结构（**一个基本结论**），在不同层次上，要封装不同的“逻辑盒子”。

最底层是方法，一个方法就是一个“逻辑盒子”，它封装了这个方法要实现的功能；其次，一个类也是一个“逻辑盒子”，它封装了这个类的属性和方法；再往上，一个包（package），一个模块（module），一个应用（applicaiton），都是一个个的“逻辑盒子”。从某种意义上来说，软件设计就是在设计这些逻辑边界，所谓的clean code，就是尽量让每一个“逻辑盒子”都封装合理——隐藏该隐藏的，暴露该暴露的，让系统呈现出一个清晰、可理解的结构，而不至于失控。

1. 方法封装的几个具体方法：抽象层次一致性，尤其是主方法/入口方法
2. 类封装是对数据和方法的封装（这句话没用，你的努力不是在实现需求，而是在应对混乱）
    1. 封装的要义在于信息隐藏，隐藏该隐藏的信息，暴露该暴露的信息。信息多了，就会杂乱，就会复杂，大脑就要晕菜
    1. 功能内聚，避免了散弹式修改
    2. 把系统中的重要领域概念挖掘出来，封装成可以复用的类，把业务语义显性化的表达出来，这种方式可以极大的增加系统的可理解性。这种对领域概念的类封装，也是DDD（Domain Driven Design，领域驱动设计）所倡导的，即明晰领域概念，并以领域模型为核心驱动系统设计。PS： **编程范式与 领域建模的关联**

## 继承 vs 组合

对于继承，子类通过super 可以访问父类的相关方法。对于java8 interface，也是类似。从这个角度看，如果将 this、super 理解为 类成员，继承父类、实现接口，像是组合的一种特殊形态。在c++里面，子类拥有父类的数据拷贝。那么java的内存对象模型和c的内存对象模型，研究一下，做个对比，还是蛮有意思的。以下图为例，UML 在展示PriorityKafkaProducer的继承和聚合关系时，将父类AbstractPriorityKafkaProducer和聚合类/成员KafkaProducer做了平级的处理。

![](/public/upload/java/priority_kafka_producer_class_diagram.png)

分解是设计的第一步，而且分解的粒度越小越好。当你可以分解出来多个关注点，每一个关注点就应该是一个独立的模块。最终的类是由这些一个一个的小模块组合而成，这种编程的方式就是面向组合编程。它相当于换了一个视角：类是由多个小模块组合而成。

如果用 Ruby，组合的表现形式就会是一个 module；而在 Scala 里，就会成为一个 trait。使用 C++ 的话，表现形式则会是私有继承。学习多种程序设计语言的重要性：**Java 只有类这种组织方式，所以，很多有差异的概念只能用类这一个概念表示出来，思维就会受到限制**，而不同的语言则提供了不同的表现形式，让概念更加清晰。

许式伟：继承是个过度设计，其实继承实现了代码复用和多态两个东西，揉在一起。在 Go 里面，组合实现代码复用，接口实现多态，彼此完全独立，非常清晰。PS： go 中 struct a 嵌进 struct b，`a.b.func()` 只是 go 的语法糖，实际上a 和b 没有任何关系。

《罗剑锋的C++实战笔记》“继承”的本意是重用代码，表述类型的从属关系（Is-A），但它却不能与现实完全对应，所以用起来就会出现很多意外情况。比如基类 Bird 有个 Fly 方法，所有的鸟类都应该继承它。但企鹅、鸵鸟这样的鸟类却不会飞，实现它们就必须改写 Fly 方法。各种编程语言为此都加上了一些“补丁”，像 C++ 就有“多态”“虚函数”“重载”，虽然解决了“继承”的问题，但也使代码复杂化了，一定程度上扭曲了“面向对象”的本意。**“面向对象编程”的关键点是“抽象”和“封装”，而“继承”“多态”并不是核心，只能算是附加品**。

《程序员修炼之道》有些人认为继承是定义新类型的一种方式，他们最喜欢设计图表，展示出类的层次结构，不幸的是，这类图表很快就会为了表示类之间的细微差别而逐层添加，最终可怕的爬满墙壁。更糟糕的是多重继承的问题，汽车可以是一种交通工具，但它也可以是一种资产、保险项目、贷款抵押品等等，正确的对此建模需要多重继承，即使你很喜欢复杂的类型树，也完全无法为你的领域准确的建模。

## 面向对象和基于对象——多态

《解密java虚拟机》面向对象编程之所以要实现多态这一特性，最主要的目的是为了消除类型之间的耦合，也就是解耦，进而有一定余度应对变化。多态得以实现的一大前提是编程语言必须是面向对象的，否则哪来的对象与函数互相绑定一说呢？函数属于对象的一部分，便具备了封装的特性，有封装才有对象。一个函数能绑定多个不同的对象，意味着多个不同的对象有相同的行为，这是抽象/继承的含义，**封装、继承成全了多态**。

大部分人写出的java 代码，可能只是基于对象。基于对象，通常指的是对数据的封装，以及提供一组方法对封装过的数据操作。比如 C 的 IO 库中的 FILE * 就可以看成是基于对象的。

面向对象的程序设计语言必须有描述对象及其相互之间关系的语言成分。这些程序设计语言可以归纳为以下几类：

1. 系统中一切事物皆为对象；
2. 对象是属性及其操作的封装体；《effective java》：尽可能地使每个类或者成员不被外界访问。
2. 对象可按其性质划分为类，
3. 对象成为类的实例；
4. 实例关系和继承关系是对象之间的静态关系；
5. 消息传递是对象之间动态联系的唯一形式，也是计算的唯一形式；
6. 方法是消息的序列。

《软件设计之美》只使用封装和继承的编程方式，我们称之为基于对象（Object Based）编程，而只有把多态加进来，才能称之为面向对象（Object Oriented）编程。也就是说，**多态是一个分水岭，将基于对象与面向对象区分开来**。软件设计是一门关注长期变化的学问，只有当你开始理解了多态，你才真正踏入应对长期变化的大门。

既然多态这么好，为什么很多程序员不能在自己的代码中很好地运用多态呢？因为多态需要构建出一个抽象。**构建抽象，需要找出不同事物的共同点，而这是最有挑战的部分**。而遮住程序员们双眼的，往往就是他们眼里的不同之处。在他们眼中，鸡就是鸡，鸭就是鸭。寻找共同点这件事，地基还是在分离关注点上。只有你能看出来，鸡和鸭都有羽毛，都养在家里，你才有机会识别出一个叫做“家禽”的概念。在构建抽象上，接口扮演着重要的角色。首先，接口将变的部分和不变的部分隔离开来。**不变的部分就是接口的约定，而变的部分就是子类各自的实现**。在软件开发中，对系统影响最大的就是变化。有时候需求一来，你的代码就要跟着改，一个可能的原因就是各种代码混在了一起。比如，一个通信协议的调整需要你改业务逻辑，这明显就是不合理的。对程序员来说，识别出变与不变，是一种很重要的能力。

很多程序员在接口中添加方法显得很随意，因为在他们心目中，并不存在**实现者和使用者之间的角色差异**。这也就造成了边界意识的欠缺，没有一个清晰的边界，其结果就是模块定义的随意，彼此之间互相影响也就在所难免。要想理解多态，首先要理解接口的价值，而理解接口，最关键的就是在于谨慎地选择接口中的方法。相对于封装和继承而言，多态对程序员的要求更高，需要你有长远的眼光，看到未来的变化，而理解好多态，也是程序员进阶的必经之路。

只要能够遵循相同的接口，就可以表现出来多态，所以，多态并不一定要依赖于继承。比如，在动态语言中，有一个常见的说法，叫 Duck Typing，就是说，如果走起来像鸭子，叫起来像鸭子，那它就是鸭子。“多态依赖于继承”只是某些程序设计语言自身的特点。你也看出来了，在面向对象本身的体系之中，**封装和多态才是重中之重**，而继承则处于一个很尴尬的位置。

以 Linux 文件系统接口为例

```c
struct file_operations {
  loff_t (*llseek) (struct file *, loff_t, int);
  ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
  ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
  int (*open) (struct inode *, struct file *);
  int (*flush) (struct file *, fl_owner_t id);
  int (*release) (struct inode *, struct file *);
  ...
}
```
假设你写一个 HelloFS，那你可以这样给它赋值：
```c
const struct file_operations hellofs_file_operations = {
    .read = hellofs_read,
    .write = hellofs_write,
};
```
只要给这个结构体赋上不同的值，就可以实现不同的文件系统。但是，这种做法有一个非常不安全的地方。既然是一个结构体的字段，那就有可能改写了它，像下面这样：

```c
void silly_operation(struct file_operations* operations) {
  operations.read = sillyfs_read;
}
```

如此一来，本来应该在 hellofs_read 运行的代码，就跑到了 sillyfs_read 里，程序很容易就崩溃了。对于 C 这种非常灵活的语言来说，你根本禁止不了这种操作，只能靠人为的规定和代码检查。到了面向对象程序设计语言这里，这种做法由一种编程结构变成了一种语法。**给函数指针赋值的操作下沉到了运行时去实现**。

[强制类型转换是抽象层次有问题](https://mp.weixin.qq.com/s/cJ0odiYcphhNBoAVjqpCZQ)我们在写代码的过程中，什么时候会用到强制类型转换呢？子类的方法超出了父类的类型定义范围，为了能使用到子类的方法，只能使用类型强制转换将类型转成子类类型。举个例子，在苹果（Apple）类上，有一个isSweet()方法是用来判断水果甜不甜的；西瓜（Watermelon）类上，有一个isJuicy()是来判断水分是否充足的；同时，它们都共同继承一个水果（Fruit）类。我们需要挑选出甜的水果和有水分的习惯，因为pick方法的入参的类型是Fruit，所以为了获得Apple和Watermelon上的特有方法，我们不得不使用instanceof做一个类型判断。这里问题出在哪里？对于这样的代码我们要如何去优化呢？仔细分析一下，我们可以发现，根本原因是因为isSweet和isJuicy的抽象层次不够，站在更高抽象层次也就是Fruit的视角看，我们挑选的就是可口的水果，只是具体到苹果我们看甜度，具体到西瓜我们看水分而已。因此，解决方法就是对isSweet和isJuicy进行抽象，并提升一个层次，在Fruit上创建一个isTasty()的抽象方法，然后让苹果和西瓜类分别去实现这个抽象方法就好了。 

## 面向对象的渊源——限定修改影响的范围

面向对象的编程产生的历史原因：**由于面向过程编程在构造系统时，无法解决重用，维护，扩展的问题，**而且逻辑过于复杂，代码晦涩难懂。PS：笔者第一次看到这句话时没有感觉，后来忘记了，看《左耳听风》时自己总结了这句，再看到这句早就看到的话时，知己二字不能形容。

[《面向对象分析与设计》读书笔记 （1）- 关键的思想](https://zhuanlan.zhihu.com/p/27106866) 要点如下

1. 复杂性是面向对象主要解决的问题,复杂系统的5个属性

	* 层次结构,复杂性常常以层次结构的形式存在,层次结构的形式

		* 组成（”part of“）层次结构
		* 是一种“("is a")层次结构
	* 相对本原，这里是指构建系统的最小单位。你不需要担心基础组件是如何实现的，只要利用其外部行为即可。举个例子，你要盖一个房子，你需要砖，水泥等，这些都是一些基础组件，但是你不要自己去生产砖，水泥。
	* 分离关注,组件内的联系通常比组件间的联系更强。这一事实实际上将组件中高频率的动作（涉及组件的内部结构）和低频率的动作（涉及组件间的相互作用）区分开来
	* 共同模式,复杂系统具有共同的模式。比如小组件的复用，比如常用方案提炼为设计模式等
	* 稳定的中间形式（注意不是中间件），复杂系统是在演变中诞生的，不要一开始就期望能够构建出一个复杂的系统。要从简单系统逐步迭代到复杂的系统。

2. 思考分解的方式

	1. 系统中每个模块代表了某个总体过程的一个主要步骤。邮寄快递时，我们先将物品准备好，找到快递员，填写快递信息，进行邮寄。在这个过程中，我们分成了4个步骤，我们更注重的是事件的顺序，而非主要关注参与者。
	2. 根据问题域中的关键抽象概念对系统进行分解。针对上面的快递邮寄的例子，采用面向对象分解时，我们分解成4个对象：物品，快递单，快递员，我。我拥有物品，然后向快递员发出请求，快递员给我快递单让我填写快递信息。然后快递员进行邮递。

3. 编程风格，Bobrow将编程风格定义为“一种组织程序的方式，基于某种编程概念模型和一种适合的语言，其目的是使得用这种风格编写的程序很清晰”

4. 对象模型的4个主要要素：抽象；封装；模块化；层次结构；3个次要要素：类型、持久、并发

5. Shaw对于抽象的定义："对一个系统的一种简单的描述或指称，强调系统的某些细节或属性同时抑制另一些细节或属性。好的抽象强调了对读者或者用户重要的细节，抑制了那些至少是暂时的非本质细节或枝节" （我以前的思维漏洞 就是不知道 抑制非本质细节）
6. 封装的意义，复杂系统的每一部分，都不应该依赖于其他部分的内部细节。要让抽象能工作，必须将实现封装起来
7. 模块化的意义
8. 层次结构的意义

## 实现

问题：面向对象特性是当前很多主流语言都支持的特性。那么要在编译器和运行时上做哪些工作，来支持面向对象的特性呢？对象在内存里的表示都有哪些不同的方式？如何实现继承和多态的特性？为什么 Java 支持基础数据类型和对象类型，而有些语言中所有的数据都是对象？要在编译技术上做哪些工作来支持纯面向对象特性？

对象的概念是它的基础，然后语言的设计者再把类型体系、软件重用机制和信息封装机制给体现出来。在这个过程中，不同的设计者会有不同的取舍。所以，希望你不要僵化地理解面向对象的概念。比如，以为面向对象就必须有类，就必须有继承；以为面向对象才导致了多态，等等。这些都是错误的理解。

要实现一门面向对象的语言，我们重点要了解三个方面的关键工作：一是编译器在语法和语义处理方面要做哪些工作；二是运行期对象的内存布局的设计；三是在存在多态的情况下，如何实现方法的绑定。

编译器前端的工作
1. 从语法角度来看，语言的设计者要设计与类的声明和使用有关的语法。
2. 在语义分析阶段，每个类会作为自定义类型被加入到符号表里。这样，在其他引用到该类型的地方，比如用该类型声明了一个变量，或者一个方法的参数或返回值里用到了该类型，编译器就能够做正确的引用消解。
3. 使用类型系统的信息，在变量赋值、函数调用等地方，会进行类型检查和推断。
对象的内存布局
1. 像 Java、Python 和 Julia 的对象，一般都有一个固定的对象头。对象头里可以保存各种信息，比如到类定义的指针、与锁有关的标志位、与垃圾收集有关的标志位，等等。
2. 对象头之后，通常就是该类的数据成员。如果存在父类，那么就既要保存父类中的成员变量，也要保存子类中的成员变量。在生成的汇编代码里，如果要访问一个类的成员变量，其实都是从对象地址加上一个偏移量，来得到成员变量的地址。

方法的静态绑定和动态绑定
1. 方法带有 private、static 或 final 关键字的时候。在编译期就知道去执行哪段字节码
2. 对于重载（Overload）的情况，也就是方法名称一样、参数个数或类型等不一样的情况，也是可以在编译期就识别出来的，所以也可以通过静态绑定。
3. 动态绑定一般通过vtable


## 其它

### 左耳听风

来自陈皓《左耳听风》付费课程，建议先看下[java 语言的动态性](http://qiankunli.github.io/2018/08/15/java_dynamic.html)

在面向对象编程里，计算机程序会被设计成彼此相关的对象，独立而又相互调用。传统程序主张将程序看做一系列指令，或一系列函数。面向对象设计中的每一个对象 都应该能够接受数据、处理数据并将数据传递给其它对象。

面向对象的缺点：通过对象来达到抽象效果， 把代码分散在不同的类里面。那要让它们执行起来，就需要将这些类粘合起来。设计模式以及ioc 等虽然精巧，但不得不怀疑点歪了科技树。一段代码的执行路径 `obj1.func1 ==> obj2.func2 ==> obj3.func3` 在函数式编程中 `func1(func2(func3))` 就解决了。

![](/public/upload/java/object_oriented_3.png)

换个角度想一下，架构设计从单体演化到微服务架构，固然一部分是单机无法负载，另一个原因就是单体 在维护和运维上的困难，比如一个小改动导致整个项目的重启。也就是说，架构设计之初，就越来越考虑可维护性和扩展性。**架构设计不只考虑实现功能，可维护性和扩展性影响了架构设计，对应的，可维护性和扩展性影响了代码结构。****指令序列或函数序列被解构，分散在各个对象中，以减少修改对整体的影响**。但从上图可以看到，面向对象的优点 也直接导致了其缺点。

宏观上的系统设计与类设计

![](/public/upload/java/object_oriented_1.png)

可以认为，db 就是controller-service-dao  这些类的状态。

微观上的类实现与系统模块实现

![](/public/upload/java/object_oriented_2.png)

你设计一个controller-service-dao 项目 制定http api 时，肯定会想业务层面会有哪些调用，绝不会一个http api 干了一半的活儿 然后让调用方自己 访问两个 http api 自己聚合数据。对应的，我们在设计类时，根据类持有的数据/状态，一个对象可以访问数据库、可以内部操作线程，但其对外提供的interface function 应该是自洽的（对外隐藏掉不必要的细节）。类似的概念可以看 [ddd(一)——领域驱动理念入门](http://qiankunli.github.io/2017/12/25/ddd.html)

### 多线程与对象的 关系

我以前的认知，线程只是一个 驱动者，驱动代码执行，对象跟线程没啥关系。一个典型的代码是

```java
class XXThread extends Thread{
    private Business business;
    public XXThread(Business business){
        this.business = business;
    }
    public void run(){  
        // 一般适用于 task之间没有关联，线程内可以闭环掉所有逻辑，无需共享数据，线程之间无需协作
        business code
    }
}
```
	
在apollo client 中，RemoteRepository 内部聚合线程 完成配置的周期性拉取，线程就是一个更新数据的手段，只是周期性执行下而已。 

```java
class Business{
    private Data data;
    public Business(){
        Executors.newSingleThread().execute(new Runnable(){
            public void run(){
                acquireDataTimely();
            }
        });
    }
    public void acquireDataTimely(){}
    public void useData(){}
    public void transferData(){}
}
```
	
从两段代码 看，线程与对象的 主从关系 完全相反。[程序的本质复杂性和元语言抽象](https://coolshell.cn/articles/10652.html)指出：程序=control + logic。 同步/异步 等 本质就是一个control，只是拉取数据的手段。因此，在我们理解程序时，同步异步不应成为本质的存在。


## 喷一喷面向对象

### 不要为了面向对象而面向对象

2019.1.2 补充[如此理解面向对象编程](https://coolshell.cn/articles/8745.html)，有一个需求：代码检查操作系统类型，若是linux 输出：linux很不错；若是windows，输出windows 很差

1. 过程化的方案
2. 一般面向对象方案（os 抽象为class，一个具体os 对应一个子class）
3. 面向对象进化：不仅弄子类，还弄一map 保存os 和 子类的关系
4. 大神 Rob Pike 对此的评论是：根本就不需要什么Object，只需要一张小小的配置表格，里面配置了对应的操作系统和你想输出的文本。这不就完了。所谓的代码进化相当疯狂和愚蠢的，这个完全误导了对编程的认知。

还有的人喜欢用Object来替换所有的if-else语句，他们甚至还喜欢把函数的行数限制在10行以内 [programming in the
twenty-first century](https://prog21.dadgum.com/156.html)
6. **那23个经典的设计模式和OO半毛钱关系没有**，只不过人家用OO来实现罢了。设计模式就三个准则：1）中意于组合而不是继承，2）依赖于接口而不是实现，3）高内聚，低耦合。你看，这完全就是Unix的设计准则。


[Don't Distract New Programmers with OOP](https://prog21.dadgum.com/93.html)The shift from procedural to OO brings with it a shift from thinking about problems and solutions to thinking about architecture. That's easy to see just by comparing a procedural Python program with an object-oriented one. The latter is almost always longer, full of extra interface and indentation and annotations. The temptation（诱惑） is to start moving trivial bits of code into classes and adding all these little methods and anticipating（预料） methods that aren't needed yet but might be someday. 封装对象、类、接口等对很多简单代码来说是不必要的。

When you're trying to help someone learn how to go from a problem statement to working code, the last thing you want is to get them sidetracked（转移话题） by faux（人造的）-engineering busywork（作业、额外工作）. Some people are going to run with those scraps（点滴） of OO knowledge and build crazy class hierarchies and end up not as focused on on what they should be learning. Other people are going to lose interest because there's a layer of extra nonsense（无意义的） that makes programming even more cumbersome（笨重的）.

面向对象逼着你除了思考问题本身外，还要思考结构、设计，很多人无此意识或功力不足， 滥用面向对象的特性，整出大量无意义的代码，使得代码复杂度大大超过了问题本身的复杂度。

### 走偏的controller-service-dao

controller-service-dao说白了，跟面向对象没啥关系，说面向过程也不算错。web 开发其实是在进行**数据处理**，这估计也是现在在倡导异步处理、反应式处理的初衷，而进行**逻辑处理**的框架，对代码设计是非常讲究的。习惯了Controller-service-dao这种思维，**在关键领域不会用类解决问题**，所有的代码都是把字段取出来计算，然后再塞回去。各种不同层面的业务计算混在一起，将来有一点调整，所有的代码都得跟着变，其实就是面向过程的代码。

面向对象几个基本概念：抽象、封装、继承、多态等，现在看，最难的就是抽象，抽象是在说啥？在厘定边界，什么活该什么类干是精确的，**变动被局限在一个很小的范围内**（比如，我把map 改成guava cache，变动越小越优秀）。理论上，不违背基本设计的变动，修改起来应该是很容易的。没有抽象，写出来的都是方法和方法的组合

一个类，有几个方法，有几个字段，叫啥名，哪些对外可见的，很重要，绝不是随意的，反应了你的设计理念。尤其是在重逻辑，轻数据处理的项目中。Controller-service-dao 给了很不好的恶习。

在一些从结构化编程起步的程序员的视角里，面向对象就是数据加函数。虽然这种理解不算完全错误，但理解的程度远远不够。面向对象是解决更大规模应用开发的一种尝试，它提升了程序员管理程序的尺度。谈到面向对象，你可能会想到面向对象的三个特点：封装、继承和多态。**封装，则是面向对象的根基**。对象之间就是靠方法调用来通信的。但这个方法调用并不是简单地把对象内部的数据通过方法暴露。因为，封装的重点在于对象提供了哪些行为，而不是有哪些数据。也就是说，即便我们把对象理解成数据加函数，**数据和函数也不是对等的地位**。函数是接口，而数据是内部的实现，正如我们一直说的那样，接口是稳定的，实现是易变的。**“封装”的要点是行为，数据只是实现细节**，而很多人习惯性的写法是面向数据的，这也是导致很多人在设计上缺乏扩展性思考的一个重要原因。

一个模型的封装应该是以行为为基础的。PS： 一个类不应该只当数据类用，除非目的就是数据类。

理解了这一点，我们来看一个很多人都有的日常编程习惯。他们编写一个类的方法时，把这个类有哪些字段写出来，然后，生成一大堆 getter 和 setter，将这些字段的访问暴露出去。**这种做法的错误就在于把数据当成了设计的核心**，这一堆的 getter 和 setter，是对于封装的破坏，它把一个类内部的实现细节暴露了出来。请注意，方法的命名，体现的是你的意图，而不是具体怎么做。所以，**getXXX 和 setXXX 绝对不是一个好的命名**。不过，在真实的项目中，有时确实需要暴露一些数据，所以，等到你确实需要暴露的时候，再去写 getter 也不迟，你一定要问问自己为什么要加 getter。至于 setter，首先，大概率是你用错了名字，应该用一个表示意图的名字；其次，setter 通常意味着修改，一个好的设计应该尽可能追求不变性。所以，setter 也是一个提示符，告诉我们，这个地方的设计可能有问题。


setter 的出现，是对于封装的破坏，它把一个类内部的实现细节暴露了出来。面向对象的封装，关键点是行为，而使用 setter 多半只是做了数据的聚合，缺少了行为的设计。setter 通常还意味着变化，一个好的设计应该尽可能追求不变性。所以，setter 也是一个提示符，告诉我们，这个地方的设计可能有问题。

## 其它

本文着重从面向对象渊源的角度来说明：**面向过程编程在构造系统时，无法解决重用，维护，扩展的问题**，进而说明面向对象将 重用、维护、扩展加入了设计理念中，进而体现在语言的方方面面。

